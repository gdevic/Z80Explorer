#ifndef CLASSCHIP_H
#define CLASSCHIP_H

#include "ClassAnnotate.h"
#include <QImage>
#include <QHash>

// Contains visual definition of a segment (wire at the same voltage level)
struct segdef
{
    uint nodenum {};                // A non-zero node (segment) number
    QVector<QPainterPath> paths {}; // Visual QPainter class' list of paths (patches) describing the area
};

// Contains individual transistor definition
struct transdef
{
    QString name;       // Transistor name (ex. 't251')
    uint gatenode;      // Node (segment) connected to its gate
    uint sourcenode;    // Node (segment) connected to its source
    uint drainnode;     // Node (segment) connected to its drain
    QRect box;          // Visual rectangle where it is (roughly) located
    //------------ experimental (3) //------------
    QPainterPath path;
};

/*
 * ClassChip contains functions to hold the visual chip data and to manipulate with a set of die images,
 * some loaded and some generated by this class code
 */
class ClassChip: public QObject
{
    Q_OBJECT

public:
    ClassChip() {};
    ClassAnnotate annotate;             // ClassChip "has-a" ClassAnnotate

    bool loadChipResources(QString dir);// Attempts to load all expected chip resources
    QImage &getImage(uint i);           // Returns the reference to the image by the image index
    QImage &getImage(QString name, bool &ok); // Returns the reference to the image by the image (embedded) name
    QList<int> getNodesAt(int x, int y);
    const QStringList getTransistorsAt(int x, int y);
    const QStringList getLayerNames();  // Returns a list of layer / image names
    const segdef *getSegment(uint nodenum); // Returns the segdef given its node number, zero-nodenum segment if not found
    const transdef *getTrans(QString name); // Returns transistor definition given its name, nullptr if not found

public slots:
    void experimental(int n);           // Runs experimental function number n
    void expDrawTransistors(QPainter &painter);

private:
    QHash<uint, segdef> m_segdefs;      // Hash of segment definitions, key is the segment node number
    QVector<transdef> m_transdefs;      // Array of transistor definitions
    QVector<QImage> m_img;              // Chip layer images
    uint m_sx {};                       // X size of all images and maps
    uint m_sy {};                       // Y size of all images and maps
    uint16_t *m_p3[3] {};               // Layer map: [0] diffusion, [1] poly, [2] metal

private:
    bool loadImages(QString dir);       // Loads chip images
    bool loadSegdefs(QString dir);      // Loads segdefs.js
    bool loadTransdefs(QString dir);    // Loads transdefs.js
    void setFirstImage(QString name);   // Sets the given image to be the first one in m_img vector
    bool addTransistorsLayer();         // Inserts an image of the transistors layer
    void drawTransistors(QImage &img);  // Draws transistors on the given image surface
    bool convertToGrayscale();          // Converts loaded images to grayscale format
    bool loadLayerMap(QString dir);     // Loads layer map
    void buildFeatureMap();             // Builds the feature map from individual layer images of a die
    void shrinkVias(QString name);      // Creates a via layer with 1x1 vias
    void createLayerMapImage(QString name); // Creates a color image from the layer map data
    // Experimental code
    void fill(const uchar *p_map, uint16_t x, uint16_t y, uint layer, uint16_t id);
    void drawFeature(uint16_t x, uint16_t y, uint layer, uint16_t id);
    void drawAllNetsAsInactive(QString name, QString nameSourceImage);
    void experimental_1();              // 3D fill layer map with vss and vcc
    void experimental_2();              // Save layer map to file
    void experimental_3();
    bool scanForTransistor(uchar const *p, QRect t, uint &x, uint &y);
    void edgeWalk(uchar const *p, QPainterPath &path, uint x, uint y);
    uint edgeWalkFindDir(uchar const *p, uint x, uint y, uint startDir);
};

#endif // CLASSCHIP_H
